### ✅ What is Flutter and what is the concept?
Flutter is an open-source UI toolkit by Google to build **natively compiled apps** from a single codebase for mobile, web, desktop, and embedded. It uses **widgets** as the building blocks of UI and supports **reactive, declarative programming**.

---

### ✅ What are the advantages of Flutter?
- Single codebase for multiple platforms (iOS, Android, Web, Desktop)
- Fast development with **hot reload** and **hot restart**
- Rich set of pre-designed widgets (Material & Cupertino)
- High performance with **Dart** and **Skia** rendering engine
- Open-source and large community support
- Beautiful UIs with customizable widgets

---

### ✅ Explain the widget tree in Flutter
In Flutter, everything is a widget. The **widget tree** is a hierarchical structure of widgets that defines the UI. Each widget is responsible for a part of the UI and can contain other widgets. The tree starts from the root widget (usually `MaterialApp` or `CupertinoApp`) and branches out to child widgets.

---

### ✅ What tech is Flutter built with?
Flutter is built with:
- **Dart** (main language)
- **C++** (engine/core rendering)
- **Skia** (graphics engine)
- **Platform channels** for native iOS (Objective-C/Swift) and Android (Java/Kotlin) communication.

---

### ✅ What is the concept of classes in Flutter?
Like in Dart, classes in Flutter define **blueprints for objects**, used to create widgets, manage state, or define models. Flutter heavily uses **OOP concepts** like inheritance, composition, and abstraction.

---

### ✅ Error handler in Flutter?
Use:
- `try-catch` for sync/async errors
- `FlutterError.onError` for framework errors
- `runZonedGuarded()` for uncaught async errors
- `ErrorWidget.builder` to customize red screen errors in UI

---

### ✅ Difference: mixin, extension, sealed, etc.

| Concept     | Purpose |
|-------------|---------|
| **Mixin**   | Reuse code across multiple classes (`with`) without inheritance. |
| **Extension** | Add functionality to existing types without changing their source. |
| **Sealed class** | A class restricted to a limited set of subclasses (Dart 3+). |
| **Abstract** | Cannot be instantiated; used for defining interfaces/contracts. |
| **Interface** | Dart doesn't have a keyword — any class can act as an interface. |

---

### ✅ MaterialApp vs CupertinoApp
- `MaterialApp`: Follows **Material Design** (Android-style)
- `CupertinoApp`: Follows **iOS-style** (Cupertino design)
Use them to match the native platform look and feel.

---

### ✅ What do you need to do before production?
- Enable **code obfuscation** for security
- Run `flutter build --release`
- Remove unused dependencies
- Check for **performance, memory leaks**
- Handle **permissions**, background modes
- Configure **app icons, splash screen, versioning**
- Sign the app (keystore or iOS certificates)

---

### ✅ What do you understand about Stream and its types?

**Stream**: A sequence of async events over time.

Types:
- `Single-subscription`: Only one listener (e.g., HTTP response)
- `Broadcast`: Multiple listeners (e.g., user events)

Used in:
- Real-time updates (chat, notifications)
- BLoC pattern
- Async data handling (e.g., Firestore, sockets)

---

### ✅ Null-aware operators

| Operator | Usage |
|----------|--------|
| `??` | Returns fallback if left is null |
| `??=` | Assigns value only if null |
| `?.` | Calls method/getter only if not null |
| `!` | Force unwrap a nullable value (use with care) |

---

### ✅ Why do we pass a function to a widget?
To allow **child widgets to call back** and notify the parent — enabling interaction and state changes (e.g., button press, form submit).

---

### ✅ What is Future in Flutter?
`Future` represents a **value that will be available later** (async). It can:
- Complete with a value or an error
- Be awaited with `await`
- Be handled with `.then()`

---

### ✅ Build types in Flutter
- **Debug**: Fast build, includes debug tools & assertions
- **Profile**: Performance testing, no debugger
- **Release**: Optimized, stripped of debug info, ready for production

---

### ✅ How to ship app to Google Play / App Store?

**For Android:**
- Update version in `pubspec.yaml` and `build.gradle`
- Sign with release key
- `flutter build apk` or `aab`
- Upload to Google Play Console

**For iOS:**
- Set version/build in Xcode
- Use provisioning profiles and certificates
- `flutter build ios`
- Upload via Xcode or Transporter to App Store Connect

---

### ✅ Explain `main()` and `runApp()`

- `main()` is the app's entry point.
- `runApp()` takes a widget (usually `MaterialApp` or `CupertinoApp`) and attaches it to the screen — it's how Flutter builds the widget tree.

---

### ✅ What is the BuildContext?
BuildContext is an object that represents the location of a widget in the widget tree. It is required for many operations, such as navigating between screens or showing dialogs.

---

### ✅ What is the pubspec.yaml file used for?
The `pubspec.yaml` is a congiguration file where to define the dependencies, assets, fonts, and other settings for a Flutter project. It is used by the Dart package manager (`pub`) to manage packages and dependencies.

---

### ✅ Explain the concept of Widget binding
`WidgetBinding` is the connection between the Flutter framework and the underlying platform. It provides an interface for managing the interaction between the framework and the platform specific code.

---

### ✅ Difference between dependency and dev_dependency
- `dependencies`: Required for the app to run in production (e.g., `http`, `provider`).
- `dev_dependencies`: Required only during development (e.g., `flutter_test`, `build_runner`). They are not included in the production build.

---

### ✅ What are types of tests in Flutter?
There are three main types of tests in Flutter:
- **Unit tests**: Test individual functions or classes (e.g., logic, models).
- **Widget tests**: Test a single widget's UI and behavior (e.g., button press, layout).
- **Integration tests**: Test the entire app or a large part of it (e.g., navigation, API calls). They run on a real device or emulator.

---