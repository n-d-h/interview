# Interview Overall

## 1. Stateless vs Stateful Widget
- **Stateless Widget**: Là widget không thay đổi trạng thái sau khi được tạo ra. Ví dụ: `Text`, `Icon`, `Container`.
  + Dùng `Stateless` khi widget không cần thay đổi trạng thái hoặc chỉ cần nhận dữ liệu từ bên ngoài.
  <br/>
- **Stateful Widget**: Là widget có thể thay đổi trạng thái trong quá trình hoạt động. Ví dụ: `Checkbox`, `TextField`, `Slider`.
  + Dùng `Stateful` khi widget cần thay đổi trạng thái hoặc có tương tác với người dùng.

---

## 2. Các loại widget trong Flutter
- **Material Design**: Là bộ widget được thiết kế theo nguyên tắc Material Design của Google. Ví dụ: `Scaffold`, `AppBar`, `FloatingActionButton`.
- **Cupertino**: Là bộ widget được thiết kế theo phong cách iOS của Apple. Ví dụ: `CupertinoNavigationBar`, `CupertinoButton`, `CupertinoPicker`.
- **Widgets cơ bản**: Là các widget cơ bản trong Flutter như `Text`, `Container`, `Row`, `Column`, `Stack`, `ListView`, `GridView`.
- **Widgets tùy chỉnh**: Là các widget do người dùng tự định nghĩa, có thể kế thừa từ `StatelessWidget` hoặc `StatefulWidget`.
- **Widgets layout**: Là các widget dùng để bố trí các widget khác, ví dụ: `Row`, `Column`, `Stack`, `GridView`, `ListView`.
- **Widgets tương tác**: Là các widget cho phép người dùng tương tác, ví dụ: `GestureDetector`, `InkWell`, `Form`, `TextField`.
- **Widgets hình ảnh**: Là các widget dùng để hiển thị hình ảnh, ví dụ: `Image`, `FadeInImage`, `NetworkImage`, `AssetImage`.
- **Widgets hoạt hình**: Là các widget hỗ trợ hoạt hình, ví dụ: `AnimatedContainer`, `AnimatedOpacity`, `Hero`, `FadeTransition`.

---

## 3. Các kiểu dữ liệu trong Dart
- **Numbers**: kiểu số, bao gồm `int` (số nguyên) và `double` (số thực).
- **Strings**: kiểu chuỗi, được định nghĩa bằng dấu nháy đơn hoặc đôi.
- **Booleans**: kiểu logic, chỉ có hai giá trị `true` và `false`.
- **Collections**: kiểu tập hợp, bao gồm `List` (danh sách), `Set` (tập hợp không trùng lặp) và `Map` (bản đồ).
  - **List**: danh sách, là một tập hợp các giá trị có thể trùng lặp.
  - **Set**: tập hợp, là một tập hợp các giá trị không trùng lặp.
  - **Map**: bản đồ, là một tập hợp các cặp key-value.
- **Runes**: kiểu ký tự Unicode, dùng để biểu diễn các ký tự đặc biệt.
- **Symbols**: kiểu ký hiệu, dùng để biểu diễn tên của các biến, hàm hoặc lớp.

---

## 4. dynamic vs var vs final vs const
- **Dynamic**: Khai báo 1 biến mà có thể thay đổi cả kiểu dữ liệu và giá trị sau đó
- **Var**: Khai báo 1 biến với kiểu dữ liệu cố định (phụ thuộc vào giá trị khởi tạo), giá trị của biến có thể thay đổi
- **Final**: Khai báo 1 hằng số, không thể thay đổi cả giá trị biến và kiểu dữ liệu

Bảng dưới đây tóm tắt sự khác nhau giữa các kiểu dữ liệu này trong Dart:
| Từ khóa | Kiểu dữ liệu | Khả năng thay đổi | Thời điểm khởi tạo | Thời điểm kiểm tra kiểu dữ liệu |
|---------|--------------|-------------------|--------------------|-------------------------------|
| dynamic | Bất kỳ kiểu dữ liệu nào | Có thể thay đổi | Thời gian chạy | Thời gian chạy |
| var     | Kiểu dữ liệu được xác định | Có thể thay đổi | Thời gian biên dịch | Thời gian biên dịch |
| final   | Kiểu dữ liệu được xác định | Không thể thay đổi | Thời gian biên dịch | Thời gian biên dịch |
| const   | Kiểu dữ liệu được xác định | Không thể thay đổi | Thời gian biên dịch | Thời gian biên dịch |

---

## 5. Vòng đời của stateful widget
- **createState()**: Được gọi khi widget được tạo ra, trả về một instance của lớp State.
- **initState()**: Được gọi ngay sau khi widget được tạo ra, dùng để khởi tạo các biến hoặc thực hiện các tác vụ ban đầu.
- **didChangeDependencies()**: Được gọi khi widget phụ thuộc vào một widget khác thay đổi, dùng để cập nhật trạng thái dựa trên các thay đổi này.
- **build()**: Được gọi để xây dựng giao diện của widget, trả về một widget con.
- **didUpdateWidget()**: Được gọi khi widget cha thay đổi, dùng để cập nhật trạng thái của widget con.
- **setState()**: Được gọi để cập nhật trạng thái của widget, làm mới giao diện.
- **deactivate()**: Được gọi khi widget bị loại bỏ khỏi cây widget, dùng để dọn dẹp tài nguyên.
- **dispose()**: Được gọi khi widget không còn được sử dụng, dùng để giải phóng tài nguyên như listener, controller, stream, v.v.

---

## 6. Các loại layout trong Flutter
- **Row**: Bố trí các widget theo chiều ngang.
- **Column**: Bố trí các widget theo chiều dọc.
- **Stack**: Bố trí các widget chồng lên nhau.
- **GridView**: Bố trí các widget theo dạng lưới.
- **ListView**: Bố trí các widget theo dạng danh sách cuộn.
- **Wrap**: Bố trí các widget theo chiều ngang hoặc dọc, tự động xuống dòng khi không đủ không gian.

---

## 7. Hot reload vs Hot restart vs Full restart
- **Hot reload**: Làm mới giao diện mà không mất trạng thái của ứng dụng. Dùng để xem nhanh các thay đổi trong mã nguồn.
- **Hot restart**: Làm mới toàn bộ ứng dụng, mất trạng thái hiện tại nhưng không cần khởi động lại ứng dụng. Dùng để áp dụng các thay đổi lớn trong mã nguồn.
- **Full restart**: Làm mới toàn bộ ứng dụng, bao gồm cả trạng thái và mã nguồn. Dùng khi cần khởi động lại ứng dụng từ đầu.

--- 

## 8. Các loại state management trong Flutter
- **setState**: Quản lý trạng thái đơn giản, dùng cho các widget nhỏ.
- **InheritedWidget**: Quản lý trạng thái cho các widget con, dùng để chia sẻ dữ liệu giữa các widget.
- **Provider**: Thư viện quản lý trạng thái phổ biến, dùng để chia sẻ dữ liệu giữa các widget mà không cần truyền qua constructor.
- **Riverpod**: Phiên bản nâng cấp của Provider, hỗ trợ nhiều tính năng hơn như lazy loading, testability.
- **Bloc**: Quản lý trạng thái theo mô hình BLoC (Business Logic Component), tách biệt logic và giao diện, dùng để xử lý các sự kiện và trạng thái.
- **GetX**: Thư viện quản lý trạng thái nhẹ, hỗ trợ nhiều tính năng như dependency injection, routing, và reactive programming.
- **MobX**: Quản lý trạng thái theo mô hình reactive programming, dùng để theo dõi và tự động cập nhật giao diện khi dữ liệu thay đổi.

---

## 9. Các loại animation trong Flutter
- **Implicit Animation**: Làm hoạt hình tự động khi thay đổi thuộc tính của widget. Ví dụ: `AnimatedContainer`, `AnimatedOpacity`, `AnimatedPositioned`.
- **Explicit Animation**: Làm hoạt hình bằng cách sử dụng `AnimationController` và `Tween`. Cần phải xác định rõ các trạng thái và thời gian hoạt hình.
- **Hero Animation**: Làm hoạt hình giữa hai widget có cùng tag, dùng để tạo hiệu ứng chuyển cảnh giữa các widget.

--- 

## 10. Các loại navigation trong Flutter
- **Điều hướng trực tiếp**: sử dụng MaterialPageRoute nhận tham số khởi tạo class màn hình điều hướng đến, giá trị trả về là một Route. Sau đó sử dụng Navigator.push để điều hướng đến route vừa tạo.
- **Điều hướng tĩnh**: khai báo trước một Map routes trong MaterialApp. Để điều hướng đến màn hình thì chúng ta sử dụng thông qua route name sử dụng phương thức Navigator.pushNamed.
- **Điều hướng động**: MaterialApp cung cấp phương thức onGenerateRoute giúp tạo route chính xác dựa trên class RouteSettings. Ưu điểm của method này là giúp bạn handle tất cả các đường dẫn trong một logic xử lý.

---

## 11. Các loại API trong Flutter
- **RESTful API**: Là giao thức truyền tải dữ liệu qua HTTP, sử dụng các phương thức như GET, POST, PUT, DELETE để tương tác với tài nguyên.
- **GraphQL API**: Là giao thức truyền tải dữ liệu qua HTTP, cho phép client yêu cầu dữ liệu theo cách tùy chỉnh, chỉ lấy những trường cần thiết.
- **WebSocket**: Là giao thức truyền tải dữ liệu hai chiều, cho phép server gửi dữ liệu đến client mà không cần yêu cầu từ client.
- **gRPC**: Là giao thức truyền tải dữ liệu hiệu quả, sử dụng HTTP/2 và Protocol Buffers để truyền tải dữ liệu nhanh chóng và tiết kiệm băng thông.
- **SOAP**: Là giao thức truyền tải dữ liệu qua XML, sử dụng các phương thức như GET, POST để tương tác với tài nguyên. SOAP thường được sử dụng trong các ứng dụng doanh nghiệp lớn.
- **Firebase**: Là nền tảng phát triển ứng dụng của Google, cung cấp các dịch vụ như Authentication, Firestore, Realtime Database, Cloud Storage, Cloud Functions, v.v. để xây dựng ứng dụng nhanh chóng và dễ dàng.

---

## 12. Các loại database trong Flutter
- **SQLite**: Là cơ sở dữ liệu quan hệ nhẹ, được tích hợp sẵn trong Flutter, dùng để lưu trữ dữ liệu cục bộ trên thiết bị.
- **Hive**: Là cơ sở dữ liệu NoSQL nhẹ, không cần cài đặt, dùng để lưu trữ dữ liệu cục bộ trên thiết bị. Hive hỗ trợ lưu trữ dữ liệu dạng key-value và có hiệu suất cao.
- **Moor**: Là thư viện ORM cho SQLite, giúp dễ dàng tương tác với cơ sở dữ liệu SQLite bằng cách sử dụng các đối tượng Dart.
- **Firebase Firestore**: Là cơ sở dữ liệu NoSQL của Firebase, cho phép lưu trữ và đồng bộ hóa dữ liệu giữa các thiết bị và nền tảng khác nhau.
- **Firebase Realtime Database**: Là cơ sở dữ liệu NoSQL của Firebase, cho phép lưu trữ và đồng bộ hóa dữ liệu theo thời gian thực giữa các thiết bị và nền tảng khác nhau.
- **ObjectBox**: Là cơ sở dữ liệu NoSQL nhẹ, hỗ trợ lưu trữ dữ liệu cục bộ trên thiết bị, có hiệu suất cao và dễ sử dụng.
- **Realm**: Là cơ sở dữ liệu NoSQL nhẹ, hỗ trợ lưu trữ dữ liệu cục bộ trên thiết bị, có hiệu suất cao và dễ sử dụng. Realm hỗ trợ cả Android và iOS.
- **SharedPreferences**: Là thư viện lưu trữ dữ liệu dạng key-value, dùng để lưu trữ các cài đặt hoặc thông tin người dùng trên thiết bị.
- **SecureStorage**: Là thư viện lưu trữ dữ liệu an toàn, dùng để lưu trữ các thông tin nhạy cảm như mật khẩu, token trên thiết bị. SecureStorage sử dụng Keychain trên iOS và Keystore trên Android để bảo vệ dữ liệu.


---

## 13. package vs plugin
- **Package**: Là một thư viện hoặc bộ mã nguồn được đóng gói lại để sử dụng trong dự án Flutter. Package có thể chứa các widget, hàm, lớp, và tài nguyên khác. Package không cần quyền truy cập vào API của hệ điều hành.
- **Plugin**: Là một loại package đặc biệt, cho phép truy cập vào các API của hệ điều hành (Android/iOS). Plugin thường được sử dụng để tích hợp các tính năng như camera, GPS, Bluetooth, v.v. Plugin cần quyền truy cập vào API của hệ điều hành và thường bao gồm mã nguồn gốc cho cả Android và iOS.
<br/>
>_**Difference**: Plugin là một loại package, nhưng không phải package nào cũng là plugin. Plugin có thể chứa mã nguồn gốc cho cả Android và iOS, trong khi package chỉ chứa mã nguồn Dart. Plugin thường yêu cầu quyền truy cập vào API của hệ điều hành, trong khi package không cần._


---

## 14. Các loại testing trong Flutter
- **Unit Testing**: Kiểm tra các đơn vị nhỏ nhất của mã nguồn, như hàm hoặc lớp. Dùng để kiểm tra tính đúng đắn của logic trong mã nguồn.
- **Widget Testing**: Kiểm tra các widget trong ứng dụng, dùng để kiểm tra giao diện và tương tác của widget. Dùng để kiểm tra xem widget có hoạt động đúng như mong đợi hay không.
- **Integration Testing**: Kiểm tra toàn bộ ứng dụng, dùng để kiểm tra xem các phần của ứng dụng có hoạt động cùng nhau đúng như mong đợi hay không. Dùng để kiểm tra xem ứng dụng có hoạt động đúng trên các thiết bị và nền tảng khác nhau hay không.
- **Golden Testing**: Kiểm tra giao diện của widget bằng cách so sánh với hình ảnh đã được lưu trữ trước đó. Dùng để kiểm tra xem giao diện của widget có thay đổi hay không.
- **Performance Testing**: Kiểm tra hiệu suất của ứng dụng, dùng để kiểm tra xem ứng dụng có hoạt động mượt mà và nhanh chóng hay không. Dùng để kiểm tra xem ứng dụng có tiêu tốn quá nhiều tài nguyên hay không.
- **Smoke Testing**: Kiểm tra xem ứng dụng có hoạt động đúng sau khi thay đổi mã nguồn hay không. Dùng để kiểm tra xem ứng dụng có bị lỗi nghiêm trọng hay không.
- **Regression Testing**: Kiểm tra xem các tính năng cũ có hoạt động đúng sau khi thay đổi mã nguồn hay không. Dùng để kiểm tra xem các tính năng cũ có bị lỗi hay không.
- **End-to-End Testing**: Kiểm tra toàn bộ quy trình của ứng dụng, từ đầu đến cuối. Dùng để kiểm tra xem ứng dụng có hoạt động đúng như mong đợi hay không.
- **UI Testing**: Kiểm tra giao diện của ứng dụng, dùng để kiểm tra xem giao diện có hoạt động đúng như mong đợi hay không. Dùng để kiểm tra xem giao diện có đẹp và dễ sử dụng hay không.
- **API Testing**: Kiểm tra các API của ứng dụng, dùng để kiểm tra xem các API có hoạt động đúng như mong đợi hay không. Dùng để kiểm tra xem các API có trả về dữ liệu đúng hay không.
- **Security Testing**: Kiểm tra tính bảo mật của ứng dụng, dùng để kiểm tra xem ứng dụng có bị tấn công hay không. Dùng để kiểm tra xem ứng dụng có bảo vệ dữ liệu người dùng hay không.
- **Usability Testing**: Kiểm tra tính dễ sử dụng của ứng dụng, dùng để kiểm tra xem ứng dụng có dễ sử dụng hay không. Dùng để kiểm tra xem ứng dụng có thân thiện với người dùng hay không.
- **Accessibility Testing**: Kiểm tra tính khả dụng của ứng dụng cho người khuyết tật, dùng để kiểm tra xem ứng dụng có dễ sử dụng cho người khuyết tật hay không. Dùng để kiểm tra xem ứng dụng có hỗ trợ các công nghệ hỗ trợ hay không.
- **Localization Testing**: Kiểm tra tính khả dụng của ứng dụng cho người dùng ở các ngôn ngữ và vùng miền khác nhau, dùng để kiểm tra xem ứng dụng có hỗ trợ nhiều ngôn ngữ hay không. Dùng để kiểm tra xem ứng dụng có hiển thị đúng ngôn ngữ và định dạng ngày tháng hay không.
- **Compatibility Testing**: Kiểm tra tính tương thích của ứng dụng với các thiết bị và nền tảng khác nhau, dùng để kiểm tra xem ứng dụng có hoạt động đúng trên các thiết bị và nền tảng khác nhau hay không. Dùng để kiểm tra xem ứng dụng có tương thích với các phiên bản hệ điều hành khác nhau hay không.
- **Load Testing**: Kiểm tra khả năng chịu tải của ứng dụng, dùng để kiểm tra xem ứng dụng có hoạt động đúng khi có nhiều người dùng cùng truy cập hay không. Dùng để kiểm tra xem ứng dụng có chịu được tải cao hay không.
- **Stress Testing**: Kiểm tra khả năng chịu tải của ứng dụng khi bị quá tải, dùng để kiểm tra xem ứng dụng có hoạt động đúng khi bị quá tải hay không. Dùng để kiểm tra xem ứng dụng có chịu được tải cao hay không.
- **Volume Testing**: Kiểm tra khả năng xử lý dữ liệu lớn của ứng dụng, dùng để kiểm tra xem ứng dụng có hoạt động đúng khi xử lý dữ liệu lớn hay không. Dùng để kiểm tra xem ứng dụng có chịu được tải cao hay không.
- **Endurance Testing**: Kiểm tra khả năng hoạt động lâu dài của ứng dụng, dùng để kiểm tra xem ứng dụng có hoạt động đúng khi chạy liên tục trong thời gian dài hay không. Dùng để kiểm tra xem ứng dụng có chịu được tải cao hay không.

---

## 15. MVC vs MVVM vs MVP

>**1. MVC (Model-View-Controller)**

#### 📌 **Khái niệm**:
Là mô hình thiết kế phần mềm phổ biến, chia ứng dụng thành 3 phần chính:

- **Model**: Quản lý dữ liệu, logic nghiệp vụ và tương tác với cơ sở dữ liệu.
- **View**: Giao diện người dùng (UI), hiển thị dữ liệu từ Model.
- **Controller**: Xử lý yêu cầu từ người dùng, điều phối dữ liệu giữa Model và View.

#### 🔄 **Luồng hoạt động**:
- Người dùng thao tác trên View ➜ Controller xử lý ➜ Model cập nhật ➜ View hiển thị dữ liệu mới.

#### 📁 **Ví dụ cấu trúc thư mục**:

```
/project-root
│
├── controllers/
│   └── UserController.java
│
├── models/
│   └── User.java
│
├── views/
│   └── UserView.html
│
└── App.java
```

---

>**2. MVP (Model-View-Presenter)**

#### 📌 **Khái niệm**:
- Là biến thể của MVC, tách phần điều phối logic ra thành **Presenter**.
- **View** chỉ nhận input từ người dùng và hiển thị dữ liệu.
- **Presenter** xử lý logic và tương tác với Model, sau đó cập nhật View.

#### 🔄 **Luồng hoạt động**:
- View gọi Presenter ➜ Presenter tương tác với Model ➜ Presenter cập nhật View.

#### 📁 **Ví dụ cấu trúc thư mục**:

```
/project-root
│
├── model/
│   └── UserModel.java
│
├── view/
│   └── UserView.java (interface)
│
├── presenter/
│   └── UserPresenter.java
│
└── App.java
```

---

>**3. MVVM (Model-View-ViewModel)**

#### 📌 **Khái niệm**:
- MVVM giúp tách biệt logic UI và logic nghiệp vụ bằng ViewModel.
- ViewModel giữ trạng thái UI và xử lý logic, còn View chỉ "quan sát" dữ liệu.
- Phổ biến trong các framework như Angular, Flutter (với Provider, Riverpod), hoặc Android (LiveData, ViewModel).

#### 🔄 **Luồng hoạt động**:
- View **binds** dữ liệu từ ViewModel ➜ ViewModel tương tác với Model ➜ dữ liệu thay đổi được **observable** và tự động cập nhật View.

#### 📁 **Ví dụ cấu trúc thư mục**:

```
/project-root
│
├── model/
│   └── UserModel.dart
│
├── view/
│   └── UserPage.dart
│
├── viewmodel/
│   └── UserViewModel.dart
│
└── main.dart
```

---

## 16. WidgetBindingObserver vs WidgetsBinding.instance.addPostFrameCallback
- **WidgetsBindingObserver**: Là một interface cho phép bạn theo dõi các sự kiện của ứng dụng như thay đổi trạng thái, thay đổi kích thước hoặc thay đổi chế độ hiển thị. Bạn có thể implement interface này trong một class và đăng ký nó với `WidgetsBinding.instance.addObserver()` để nhận thông báo khi có sự kiện xảy ra.

- **WidgetsBinding.instance.addPostFrameCallback**: Là một phương thức cho phép bạn đăng ký một callback sẽ được gọi sau khi khung hình hiện tại đã được vẽ. Điều này hữu ích khi bạn muốn thực hiện một số tác vụ sau khi giao diện đã được cập nhật, chẳng hạn như lấy kích thước của một widget hoặc thực hiện các hoạt động liên quan đến giao diện.
<br/>
>_**Sự khác biệt**: `WidgetsBindingObserver` được sử dụng để theo dõi các sự kiện của ứng dụng, trong khi `addPostFrameCallback` được sử dụng để thực hiện các tác vụ sau khi giao diện đã được cập nhật. Bạn có thể sử dụng cả hai trong cùng một ứng dụng, nhưng chúng phục vụ cho các mục đích khác nhau._

---

Dưới đây là phần giải thích đầy đủ cho mục **AppLifeCycleState** với đầy đủ các trạng thái và mô tả:

---

## 17. AppLifeCycleState là gì?

- **`AppLifecycleState`** là một **enum** trong Flutter dùng để theo dõi **vòng đời của ứng dụng** (application lifecycle).
- Được sử dụng trong các trường hợp như: tạm dừng app, quay lại app, lưu trạng thái, hoặc xử lý kết nối mạng theo trạng thái app.

### 🧩 Các trạng thái chính:

| Trạng thái        | Mô tả |
|-------------------|-------|
| `resumed`         | Ứng dụng đang **hoạt động** và **hiển thị** trên màn hình. |
| `inactive`        | Ứng dụng **tạm ngừng hoạt động**, không nhận input, có thể đang trong quá trình chuyển đổi trạng thái. |
| `paused`          | Ứng dụng **đã bị ẩn** (chuyển sang background), không tương tác với người dùng. |
| `detached`        | Ứng dụng **bị tách khỏi UI host**, thường thấy trên nền tảng như Flutter web hoặc trong một số trường hợp kỹ thuật đặc biệt. |

### 💡 Cách sử dụng:

```dart
class MyAppState extends State<MyApp> with WidgetsBindingObserver {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused) {
      print('App đang ở background');
    }
  }

  ...
}
```

> Bạn có thể dùng nó để **lưu trạng thái**, **ngắt kết nối socket**, hoặc **tạm dừng video stream** khi app vào background.

---

Dưới đây là phần hoàn chỉnh cho câu hỏi **MethodChannel là gì?**, bao gồm cả khái niệm và ví dụ cụ thể:

---

## 18. MethodChannel là gì?

- **`MethodChannel`** là một lớp trong Flutter dùng để **giao tiếp hai chiều giữa Dart và mã native** (Java/Kotlin cho Android, Swift/Objective-C cho iOS).
- Cho phép bạn **gọi các phương thức gốc từ Dart** hoặc **nhận dữ liệu trả về từ native**, khi Flutter chưa hỗ trợ trực tiếp tính năng đó (ví dụ: lấy pin, cảm biến, camera nâng cao, truyền dữ liệu từ Bluetooth...).

#### ✅ Khi nào dùng MethodChannel?

- Khi bạn cần sử dụng **API native mà Flutter không hỗ trợ sẵn**.
- Ví dụ: lấy mức pin, mở app khác, quét vân tay bằng hardware, truyền dữ liệu NFC,...

<br/>

#### 🔧 Ví dụ cơ bản (Gọi từ Dart → Android)

```dart
import 'package:flutter/services.dart';
import 'package:flutter/material.dart';

class BatteryLevelWidget extends StatefulWidget {
  @override
  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();
}

class _BatteryLevelWidgetState extends State<BatteryLevelWidget> {
  static const platform = MethodChannel('samples.flutter.dev/battery');
  String _batteryLevel = 'Unknown battery level.';

  Future<void> _getBatteryLevel() async {
    try {
      final int result = await platform.invokeMethod('getBatteryLevel');
      setState(() {
        _batteryLevel = 'Battery level at $result%.';
      });
    } on PlatformException catch (e) {
      _batteryLevel = "Failed to get battery level: '${e.message}'.";
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(_batteryLevel),
        ElevatedButton(
          onPressed: _getBatteryLevel,
          child: Text("Get Battery Level"),
        ),
      ],
    );
  }
}
```
<br/>

#### 🧩 Android side (MainActivity.kt)

```kotlin
class MainActivity: FlutterActivity() {
  private val CHANNEL = "samples.flutter.dev/battery"

  override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
    super.configureFlutterEngine(flutterEngine)

    MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler {
      call, result ->
      if (call.method == "getBatteryLevel") {
        val batteryLevel = getBatteryLevel()
        if (batteryLevel != -1) {
          result.success(batteryLevel)
        } else {
          result.error("UNAVAILABLE", "Battery level not available.", null)
        }
      } else {
        result.notImplemented()
      }
    }
  }

  private fun getBatteryLevel(): Int {
    val batteryManager = getSystemService(BATTERY_SERVICE) as BatteryManager
    return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
  }
}
```

<br/>


#### 🍎 iOS side (Swift – `AppDelegate.swift`)

#### Bước 1: Mở file `ios/Runner/AppDelegate.swift` và thêm đoạn sau:

```swift
import UIKit
import Flutter

@UIApplicationMain
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {

    let controller = window?.rootViewController as! FlutterViewController
    let batteryChannel = FlutterMethodChannel(name: "samples.flutter.dev/battery",
                                              binaryMessenger: controller.binaryMessenger)
    
    batteryChannel.setMethodCallHandler({
      (call: FlutterMethodCall, result: @escaping FlutterResult) -> Void in
      if call.method == "getBatteryLevel" {
        self.receiveBatteryLevel(result: result)
      } else {
        result(FlutterMethodNotImplemented)
      }
    })

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  private func receiveBatteryLevel(result: FlutterResult) {
    let device = UIDevice.current
    device.isBatteryMonitoringEnabled = true
    let batteryLevel = device.batteryLevel

    if batteryLevel == -1.0 {
      result(FlutterError(code: "UNAVAILABLE",
                          message: "Battery level not available.",
                          details: nil))
    } else {
      result(Int(batteryLevel * 100))
    }
  }
}
```

<br/>

#### ✅ Tổng kết lại flow hoạt động:

| Vai trò        | Công nghệ           | Mục tiêu                              |
|----------------|---------------------|----------------------------------------|
| UI             | Flutter (Dart)      | Hiển thị nút bấm và mức pin            |
| Giao tiếp      | MethodChannel       | Cầu nối giữa Dart ↔ Native             |
| Native Android | Kotlin/Java         | Lấy mức pin từ `BatteryManager`       |
| Native iOS     | Swift/Objective-C   | Lấy mức pin từ `UIDevice.batteryLevel` |

---












