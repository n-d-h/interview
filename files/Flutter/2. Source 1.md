# Interview Overall

## 1. Stateless vs Stateful Widget
- **Stateless Widget**: Là widget không thay đổi trạng thái sau khi được tạo ra. Ví dụ: `Text`, `Icon`, `Container`.
  + Dùng `Stateless` khi widget không cần thay đổi trạng thái hoặc chỉ cần nhận dữ liệu từ bên ngoài.
  <br/>
- **Stateful Widget**: Là widget có thể thay đổi trạng thái trong quá trình hoạt động. Ví dụ: `Checkbox`, `TextField`, `Slider`.
  + Dùng `Stateful` khi widget cần thay đổi trạng thái hoặc có tương tác với người dùng.

---

## 2. Các loại widget trong Flutter
- **Material Design**: Là bộ widget được thiết kế theo nguyên tắc Material Design của Google. Ví dụ: `Scaffold`, `AppBar`, `FloatingActionButton`.
- **Cupertino**: Là bộ widget được thiết kế theo phong cách iOS của Apple. Ví dụ: `CupertinoNavigationBar`, `CupertinoButton`, `CupertinoPicker`.
- **Widgets cơ bản**: Là các widget cơ bản trong Flutter như `Text`, `Container`, `Row`, `Column`, `Stack`, `ListView`, `GridView`.
- **Widgets tùy chỉnh**: Là các widget do người dùng tự định nghĩa, có thể kế thừa từ `StatelessWidget` hoặc `StatefulWidget`.
- **Widgets layout**: Là các widget dùng để bố trí các widget khác, ví dụ: `Row`, `Column`, `Stack`, `GridView`, `ListView`.
- **Widgets tương tác**: Là các widget cho phép người dùng tương tác, ví dụ: `GestureDetector`, `InkWell`, `Form`, `TextField`.
- **Widgets hình ảnh**: Là các widget dùng để hiển thị hình ảnh, ví dụ: `Image`, `FadeInImage`, `NetworkImage`, `AssetImage`.
- **Widgets hoạt hình**: Là các widget hỗ trợ hoạt hình, ví dụ: `AnimatedContainer`, `AnimatedOpacity`, `Hero`, `FadeTransition`.

---

## 3. Các kiểu dữ liệu trong Dart
- **Numbers**: kiểu số, bao gồm `int` (số nguyên) và `double` (số thực).
- **Strings**: kiểu chuỗi, được định nghĩa bằng dấu nháy đơn hoặc đôi.
- **Booleans**: kiểu logic, chỉ có hai giá trị `true` và `false`.
- **Collections**: kiểu tập hợp, bao gồm `List` (danh sách), `Set` (tập hợp không trùng lặp) và `Map` (bản đồ).
  - **List**: danh sách, là một tập hợp các giá trị có thể trùng lặp.
  - **Set**: tập hợp, là một tập hợp các giá trị không trùng lặp.
  - **Map**: bản đồ, là một tập hợp các cặp key-value.
- **Runes**: kiểu ký tự Unicode, dùng để biểu diễn các ký tự đặc biệt.
- **Symbols**: kiểu ký hiệu, dùng để biểu diễn tên của các biến, hàm hoặc lớp.

---

## 4. dynamic vs var vs final vs const
- **Dynamic**: Khai báo 1 biến mà có thể thay đổi cả kiểu dữ liệu và giá trị sau đó
- **Var**: Khai báo 1 biến với kiểu dữ liệu cố định (phụ thuộc vào giá trị khởi tạo), giá trị của biến có thể thay đổi
- **Final**: Khai báo 1 hằng số, không thể thay đổi cả giá trị biến và kiểu dữ liệu
- **Const**: Khai báo 1 hằng số, không thể thay đổi cả giá trị biến và kiểu dữ liệu, nhưng có thể khởi tạo trước khi biên dịch (compile time).

Bảng dưới đây tóm tắt sự khác nhau giữa các kiểu dữ liệu này trong Dart:
| Từ khóa | Kiểu dữ liệu | Khả năng thay đổi | Thời điểm khởi tạo | Thời điểm kiểm tra kiểu dữ liệu |
|---------|--------------|-------------------|--------------------|-------------------------------|
| dynamic | Bất kỳ kiểu dữ liệu nào | Có thể thay đổi | Thời gian chạy | Thời gian chạy |
| var     | Kiểu dữ liệu được xác định | Có thể thay đổi | Thời gian biên dịch | Thời gian biên dịch |
| final   | Kiểu dữ liệu được xác định | Không thể thay đổi | Thời gian biên dịch | Thời gian biên dịch |
| const   | Kiểu dữ liệu được xác định | Không thể thay đổi | Thời gian biên dịch | Thời gian biên dịch |

---

## 5. Vòng đời của stateful widget
- **createState()**: Được gọi khi widget được tạo ra, trả về một instance của lớp State.
- **initState()**: Được gọi ngay sau khi widget được tạo ra, dùng để khởi tạo các biến hoặc thực hiện các tác vụ ban đầu.
- **didChangeDependencies()**: Được gọi khi widget phụ thuộc vào một widget khác thay đổi, dùng để cập nhật trạng thái dựa trên các thay đổi này.
- **build()**: Được gọi để xây dựng giao diện của widget, trả về một widget con.
- **didUpdateWidget()**: Được gọi khi widget cha thay đổi, dùng để cập nhật trạng thái của widget con.
- **setState()**: Được gọi để cập nhật trạng thái của widget, làm mới giao diện.
- **deactivate()**: Được gọi khi widget bị loại bỏ khỏi cây widget, dùng để dọn dẹp tài nguyên.
- **dispose()**: Được gọi khi widget không còn được sử dụng, dùng để giải phóng tài nguyên như listener, controller, stream, v.v.

`English version`:
Within the lifecycle of a Stateful widget, the following methods are called in order:
- **createState()**: Called when the widget is created, returns an instance of the State class.
- **initState()**: Called immediately after the widget is created, used to initialize variables or perform initial tasks.
- **didChangeDependencies()**: Called when the widget depends on another widget that changes, used to update the state based on these changes.
- **build()**: Called to build the widget's UI, and is recalled whenever the widget needs to be rebuilt.
- **didUpdateWidget()**: Called when the parent widget changes, used to update the state of the child widget.
- **setState()**: Called to update the widget's state, refreshes the interface.
- **deactivate()**: Called when the widget is removed from the widget tree, used to clean up resources.
- **dispose()**: Called when the widget is no longer used, used to free up resources like listeners, controllers, streams, etc.

---

## 6. Các loại layout trong Flutter
- **Row**: Bố trí các widget theo chiều ngang.
- **Column**: Bố trí các widget theo chiều dọc.
- **Stack**: Bố trí các widget chồng lên nhau.
- **GridView**: Bố trí các widget theo dạng lưới.
- **ListView**: Bố trí các widget theo dạng danh sách cuộn.
- **Wrap**: Bố trí các widget theo chiều ngang hoặc dọc, tự động xuống dòng khi không đủ không gian.

---

## 7. Hot reload vs Hot restart vs Full restart
- **Hot reload**: Làm mới giao diện mà không mất trạng thái của ứng dụng. Dùng để xem nhanh các thay đổi trong mã nguồn.
- **Hot restart**: Làm mới toàn bộ ứng dụng, mất trạng thái hiện tại nhưng không cần khởi động lại ứng dụng. Dùng để áp dụng các thay đổi lớn trong mã nguồn.
- **Full restart**: Làm mới toàn bộ ứng dụng, bao gồm cả trạng thái và mã nguồn. Dùng khi cần khởi động lại ứng dụng từ đầu.

`English version:`

- **Hot reload**: Refreshes the UI without losing the current state of the application. Used to quickly see changes in the source code.
- **Hot restart**: Rebuilds the app from the main() method and resets the app state, but does not recompile the native code or relaunch the emulator.
- **Full restart**: Completely recompiles the app from scratch, terminates the Dart VM, and launches a brand new instance.

--- 

## 8. Các loại state management trong Flutter
- **setState**: Quản lý trạng thái đơn giản, dùng cho các widget nhỏ.
- **InheritedWidget**: Quản lý trạng thái cho các widget con, dùng để chia sẻ dữ liệu giữa các widget.
- **Provider**: Thư viện quản lý trạng thái phổ biến, dùng để chia sẻ dữ liệu giữa các widget mà không cần truyền qua constructor.
- **Riverpod**: Phiên bản nâng cấp của Provider, hỗ trợ nhiều tính năng hơn như lazy loading, testability.
- **Bloc**: Quản lý trạng thái theo mô hình BLoC (Business Logic Component), tách biệt logic và giao diện, dùng để xử lý các sự kiện và trạng thái.
- **GetX**: Thư viện quản lý trạng thái nhẹ, hỗ trợ nhiều tính năng như dependency injection, routing, và reactive programming.
- **MobX**: Quản lý trạng thái theo mô hình reactive programming, dùng để theo dõi và tự động cập nhật giao diện khi dữ liệu thay đổi.

---

## 9. Các loại animation trong Flutter
- **Implicit Animation**: Làm hoạt hình tự động khi thay đổi thuộc tính của widget. Ví dụ: `AnimatedContainer`, `AnimatedOpacity`, `AnimatedPositioned`.
- **Explicit Animation**: Làm hoạt hình bằng cách sử dụng `AnimationController` và `Tween`. Cần phải xác định rõ các trạng thái và thời gian hoạt hình.
- **Hero Animation**: Làm hoạt hình giữa hai widget có cùng tag, dùng để tạo hiệu ứng chuyển cảnh giữa các widget.

--- 

## 10. Các loại navigation trong Flutter
- **Điều hướng trực tiếp**: sử dụng MaterialPageRoute nhận tham số khởi tạo class màn hình điều hướng đến, giá trị trả về là một Route. Sau đó sử dụng Navigator.push để điều hướng đến route vừa tạo.
- **Điều hướng tĩnh**: khai báo trước một Map routes trong MaterialApp. Để điều hướng đến màn hình thì chúng ta sử dụng thông qua route name sử dụng phương thức Navigator.pushNamed.
- **Điều hướng động**: MaterialApp cung cấp phương thức onGenerateRoute giúp tạo route chính xác dựa trên class RouteSettings. Ưu điểm của method này là giúp bạn handle tất cả các đường dẫn trong một logic xử lý.

`English version`:
- **Direct Navigation**: Uses `MaterialPageRoute` to create a route with the target screen class as a parameter. The return value is a `Route`, which is then used with `Navigator.push` to navigate to the created route.
- **Static Navigation**: Declares a `Map<String, WidgetBuilder>` in `MaterialApp` to define routes. Navigation is done using `Navigator.pushNamed` with the route name.
- **Dynamic Navigation**: Uses `onGenerateRoute` in `MaterialApp` to create routes based on `RouteSettings`. This method allows handling all routes in a single logic, making it easier to manage complex navigation scenarios.

---

## 11. Các loại API trong Flutter
- **RESTful API**: Là giao thức truyền tải dữ liệu qua HTTP, sử dụng các phương thức như GET, POST, PUT, DELETE để tương tác với tài nguyên.
- **GraphQL API**: Là giao thức truyền tải dữ liệu qua HTTP, cho phép client yêu cầu dữ liệu theo cách tùy chỉnh, chỉ lấy những trường cần thiết.
- **WebSocket**: Là giao thức truyền tải dữ liệu hai chiều, cho phép server gửi dữ liệu đến client mà không cần yêu cầu từ client.
- **gRPC**: Là giao thức truyền tải dữ liệu hiệu quả, sử dụng HTTP/2 và Protocol Buffers để truyền tải dữ liệu nhanh chóng và tiết kiệm băng thông.
- **SOAP**: Là giao thức truyền tải dữ liệu qua XML, sử dụng các phương thức như GET, POST để tương tác với tài nguyên. SOAP thường được sử dụng trong các ứng dụng doanh nghiệp lớn.
- **Firebase**: Là nền tảng phát triển ứng dụng của Google, cung cấp các dịch vụ như Authentication, Firestore, Realtime Database, Cloud Storage, Cloud Functions, v.v. để xây dựng ứng dụng nhanh chóng và dễ dàng.

---

## 12. Các loại database trong Flutter
- **SQLite**: Là cơ sở dữ liệu quan hệ nhẹ, được tích hợp sẵn trong Flutter, dùng để lưu trữ dữ liệu cục bộ trên thiết bị.
- **Hive**: Là cơ sở dữ liệu NoSQL nhẹ, không cần cài đặt, dùng để lưu trữ dữ liệu cục bộ trên thiết bị. Hive hỗ trợ lưu trữ dữ liệu dạng key-value và có hiệu suất cao.
- **Moor**: Là thư viện ORM cho SQLite, giúp dễ dàng tương tác với cơ sở dữ liệu SQLite bằng cách sử dụng các đối tượng Dart.
- **Firebase Firestore**: Là cơ sở dữ liệu NoSQL của Firebase, cho phép lưu trữ và đồng bộ hóa dữ liệu giữa các thiết bị và nền tảng khác nhau.
- **Firebase Realtime Database**: Là cơ sở dữ liệu NoSQL của Firebase, cho phép lưu trữ và đồng bộ hóa dữ liệu theo thời gian thực giữa các thiết bị và nền tảng khác nhau.
- **ObjectBox**: Là cơ sở dữ liệu NoSQL nhẹ, hỗ trợ lưu trữ dữ liệu cục bộ trên thiết bị, có hiệu suất cao và dễ sử dụng.
- **Realm**: Là cơ sở dữ liệu NoSQL nhẹ, hỗ trợ lưu trữ dữ liệu cục bộ trên thiết bị, có hiệu suất cao và dễ sử dụng. Realm hỗ trợ cả Android và iOS.
- **SharedPreferences**: Là thư viện lưu trữ dữ liệu dạng key-value, dùng để lưu trữ các cài đặt hoặc thông tin người dùng trên thiết bị.
- **SecureStorage**: Là thư viện lưu trữ dữ liệu an toàn, dùng để lưu trữ các thông tin nhạy cảm như mật khẩu, token trên thiết bị. SecureStorage sử dụng Keychain trên iOS và Keystore trên Android để bảo vệ dữ liệu.


---

## 13. package vs plugin
- **Package**: Là một thư viện hoặc bộ mã nguồn được đóng gói lại để sử dụng trong dự án Flutter. Package có thể chứa các widget, hàm, lớp, và tài nguyên khác. Package không cần quyền truy cập vào API của hệ điều hành.
- **Plugin**: Là một loại package đặc biệt, cho phép truy cập vào các API của hệ điều hành (Android/iOS). Plugin thường được sử dụng để tích hợp các tính năng như camera, GPS, Bluetooth, v.v. Plugin cần quyền truy cập vào API của hệ điều hành và thường bao gồm mã nguồn gốc cho cả Android và iOS.
<br/>

>_**Difference**: Plugin là một loại package, nhưng không phải package nào cũng là plugin. Plugin có thể chứa mã nguồn gốc cho cả Android và iOS, trong khi package chỉ chứa mã nguồn Dart. Plugin thường yêu cầu quyền truy cập vào API của hệ điều hành, trong khi package không cần._

`English version:`

- **Package**: A library or set of source code packaged for use in a Flutter project. It can contain widgets, functions, classes, and other resources. Packages do not require access to the operating system's APIs.
- **Plugin**: A special type of package that allows access to the operating system's APIs (Android/iOS). Plugins are often used to integrate features like camera, GPS, Bluetooth, etc. They require access to the operating system's APIs and usually include native code for both Android and iOS.
<br/>

>_**Difference**: A plugin is a type of package, but not all packages are plugins. Plugins can contain native code for both Android and iOS, while packages only contain Dart code. Plugins typically require access to the operating system's APIs, while packages do not._


---

## 14. Các loại testing trong Flutter
- **Unit Testing**: Kiểm tra các đơn vị nhỏ nhất của mã nguồn, như hàm hoặc lớp. Dùng để kiểm tra tính đúng đắn của logic trong mã nguồn.
- **Widget Testing**: Kiểm tra các widget trong ứng dụng, dùng để kiểm tra giao diện và tương tác của widget. Dùng để kiểm tra xem widget có hoạt động đúng như mong đợi hay không.
- **Integration Testing**: Kiểm tra toàn bộ ứng dụng, dùng để kiểm tra xem các phần của ứng dụng có hoạt động cùng nhau đúng như mong đợi hay không. Dùng để kiểm tra xem ứng dụng có hoạt động đúng trên các thiết bị và nền tảng khác nhau hay không.
- **Golden Testing**: Kiểm tra giao diện của widget bằng cách so sánh với hình ảnh đã được lưu trữ trước đó. Dùng để kiểm tra xem giao diện của widget có thay đổi hay không.
- **Performance Testing**: Kiểm tra hiệu suất của ứng dụng, dùng để kiểm tra xem ứng dụng có hoạt động mượt mà và nhanh chóng hay không. Dùng để kiểm tra xem ứng dụng có tiêu tốn quá nhiều tài nguyên hay không.
- **Smoke Testing**: Kiểm tra xem ứng dụng có hoạt động đúng sau khi thay đổi mã nguồn hay không. Dùng để kiểm tra xem ứng dụng có bị lỗi nghiêm trọng hay không.
- **Regression Testing**: Kiểm tra xem các tính năng cũ có hoạt động đúng sau khi thay đổi mã nguồn hay không. Dùng để kiểm tra xem các tính năng cũ có bị lỗi hay không.
- **End-to-End Testing**: Kiểm tra toàn bộ quy trình của ứng dụng, từ đầu đến cuối. Dùng để kiểm tra xem ứng dụng có hoạt động đúng như mong đợi hay không.
- **UI Testing**: Kiểm tra giao diện của ứng dụng, dùng để kiểm tra xem giao diện có hoạt động đúng như mong đợi hay không. Dùng để kiểm tra xem giao diện có đẹp và dễ sử dụng hay không.
- **API Testing**: Kiểm tra các API của ứng dụng, dùng để kiểm tra xem các API có hoạt động đúng như mong đợi hay không. Dùng để kiểm tra xem các API có trả về dữ liệu đúng hay không.
- **Security Testing**: Kiểm tra tính bảo mật của ứng dụng, dùng để kiểm tra xem ứng dụng có bị tấn công hay không. Dùng để kiểm tra xem ứng dụng có bảo vệ dữ liệu người dùng hay không.
- **Usability Testing**: Kiểm tra tính dễ sử dụng của ứng dụng, dùng để kiểm tra xem ứng dụng có dễ sử dụng hay không. Dùng để kiểm tra xem ứng dụng có thân thiện với người dùng hay không.
- **Accessibility Testing**: Kiểm tra tính khả dụng của ứng dụng cho người khuyết tật, dùng để kiểm tra xem ứng dụng có dễ sử dụng cho người khuyết tật hay không. Dùng để kiểm tra xem ứng dụng có hỗ trợ các công nghệ hỗ trợ hay không.
- **Localization Testing**: Kiểm tra tính khả dụng của ứng dụng cho người dùng ở các ngôn ngữ và vùng miền khác nhau, dùng để kiểm tra xem ứng dụng có hỗ trợ nhiều ngôn ngữ hay không. Dùng để kiểm tra xem ứng dụng có hiển thị đúng ngôn ngữ và định dạng ngày tháng hay không.
- **Compatibility Testing**: Kiểm tra tính tương thích của ứng dụng với các thiết bị và nền tảng khác nhau, dùng để kiểm tra xem ứng dụng có hoạt động đúng trên các thiết bị và nền tảng khác nhau hay không. Dùng để kiểm tra xem ứng dụng có tương thích với các phiên bản hệ điều hành khác nhau hay không.
- **Load Testing**: Kiểm tra khả năng chịu tải của ứng dụng, dùng để kiểm tra xem ứng dụng có hoạt động đúng khi có nhiều người dùng cùng truy cập hay không. Dùng để kiểm tra xem ứng dụng có chịu được tải cao hay không.
- **Stress Testing**: Kiểm tra khả năng chịu tải của ứng dụng khi bị quá tải, dùng để kiểm tra xem ứng dụng có hoạt động đúng khi bị quá tải hay không. Dùng để kiểm tra xem ứng dụng có chịu được tải cao hay không.
- **Volume Testing**: Kiểm tra khả năng xử lý dữ liệu lớn của ứng dụng, dùng để kiểm tra xem ứng dụng có hoạt động đúng khi xử lý dữ liệu lớn hay không. Dùng để kiểm tra xem ứng dụng có chịu được tải cao hay không.
- **Endurance Testing**: Kiểm tra khả năng hoạt động lâu dài của ứng dụng, dùng để kiểm tra xem ứng dụng có hoạt động đúng khi chạy liên tục trong thời gian dài hay không. Dùng để kiểm tra xem ứng dụng có chịu được tải cao hay không.

---

## 15. 📐 **MVC vs MVP vs MVVM trong Flutter**

### **1. MVC (Model-View-Controller)**

#### 📌 **Khái niệm**:
- **Model**: Quản lý dữ liệu và logic nghiệp vụ (có thể là class hoặc service).
- **View**: UI - các `Widget`.
- **Controller**: Một lớp trung gian xử lý logic, như `Controller`, `Cubit`, hoặc `Service`.

#### 🔄 **Luồng hoạt động**:
> View ➝ Controller ➝ Model ➝ Controller ➝ View

#### 📁 **Ví dụ cấu trúc thư mục**:
```
/lib
│
├── controllers/
│   └── user_controller.dart
│
├── models/
│   └── user_model.dart
│
├── views/
│   └── user_page.dart
│
└── main.dart
```

#### ✅ **Khi nào dùng?**
- Dễ tiếp cận cho người mới.
- Ứng dụng nhỏ hoặc demo đơn giản.

<br/>

### **2. MVP (Model-View-Presenter)**

#### 📌 **Khái niệm**:
- View và logic được tách biệt rõ ràng.
- **View**: Giao diện (Widgets), chỉ hiển thị và nhận input.
- **Presenter**: Xử lý mọi logic, cập nhật View qua interface hoặc callback.

#### 🔄 **Luồng hoạt động**:
> View ➝ Presenter ➝ Model ➝ Presenter ➝ View

#### 📁 **Ví dụ cấu trúc thư mục**:
```
/lib
│
├── models/
│   └── user_model.dart
│
├── presenters/
│   └── user_presenter.dart
│
├── views/
│   └── user_view.dart
│   └── user_page.dart
│
└── main.dart
```

#### ✅ **Khi nào dùng?**
- Khi muốn kiểm soát logic chặt chẽ.
- View chỉ tập trung vào UI, logic di chuyển sang Presenter.

<br/>

### **3. MVVM (Model-View-ViewModel)** – ✅ **Được dùng phổ biến trong Flutter**

#### 📌 **Khái niệm**:
- ViewModel là nơi xử lý logic và giữ trạng thái của UI.
- View chỉ "nghe" dữ liệu từ ViewModel thông qua `Provider`, `Riverpod`, `Bloc`, `ChangeNotifier`,...

#### 🔄 **Luồng hoạt động**:
> View ➝ ViewModel ↔ Model  
> (dữ liệu được bind tự động từ ViewModel ➝ View)

#### 📁 **Ví dụ cấu trúc thư mục**:
```
/lib
│
├── models/
│   └── user_model.dart
│
├── viewmodels/
│   └── user_viewmodel.dart
│
├── views/
│   └── user_page.dart
│
└── main.dart
```

#### ✅ **Khi nào dùng?**
- Ứng dụng trung bình đến lớn.
- Muốn tách biệt rõ ràng UI và logic, dễ test, dễ mở rộng.

#### 🔧 Gợi ý sử dụng:
- Với `ChangeNotifier` → đơn giản cho MVVM.
- Với `Bloc`, `Cubit`, `Riverpod` → hiện đại và mạnh mẽ hơn.

---

## 16. WidgetBindingObserver vs WidgetsBinding.instance.addPostFrameCallback
- **WidgetsBindingObserver**: Là một interface cho phép bạn theo dõi các sự kiện của ứng dụng như thay đổi trạng thái, thay đổi kích thước hoặc thay đổi chế độ hiển thị. Bạn có thể implement interface này trong một class và đăng ký nó với `WidgetsBinding.instance.addObserver()` để nhận thông báo khi có sự kiện xảy ra.

- **WidgetsBinding.instance.addPostFrameCallback**: Là một phương thức cho phép bạn đăng ký một callback sẽ được gọi sau khi khung hình hiện tại đã được vẽ. Điều này hữu ích khi bạn muốn thực hiện một số tác vụ sau khi giao diện đã được cập nhật, chẳng hạn như lấy kích thước của một widget hoặc thực hiện các hoạt động liên quan đến giao diện.
<br/>
>_**Sự khác biệt**: `WidgetsBindingObserver` được sử dụng để theo dõi các sự kiện của ứng dụng, trong khi `addPostFrameCallback` được sử dụng để thực hiện các tác vụ sau khi giao diện đã được cập nhật. Bạn có thể sử dụng cả hai trong cùng một ứng dụng, nhưng chúng phục vụ cho các mục đích khác nhau._

Bạn nên sử dụng `WidgetsBindingObserver` khi bạn cần **theo dõi và phản hồi** các sự kiện vòng đời hoặc thay đổi môi trường của ứng dụng Flutter, ví dụ:

1. **App Lifecycle (Ứng dụng foreground/background)**  
   – Khi bạn cần tạm dừng/tiếp tục các thao tác nặng (video, audio, kết nối WebSocket, timer…) khi người dùng chuyển app ra background hoặc quay lại.  
   – Ví dụ: tự động lưu data khi app vào background, hoặc resume video khi app trở lại foreground.

2. **Screen Metrics (Thay đổi kích thước màn hình/orientation)**  
   – Khi bạn muốn lắng nghe sự kiện thay đổi kích thước khung vẽ, chẳng hạn device xoay ngang/dọc hoặc keyboard bật/tắt để điều chỉnh layout.  

3. **Locale Changes (Thay đổi ngôn ngữ)**  
   – Khi app hỗ trợ đa ngôn ngữ và bạn cần cập nhật lại UI khi người dùng đổi locale.

4. **Text Scale / Accessibility (Thay đổi kích thước font, động lực truy cập)**  
   – Khi bạn muốn đảm bảo UI phản hồi kịp thời khi người dùng thay đổi cỡ chữ hoặc các thiết lập trợ năng.

<br/>

#### 📋 Cách dùng cơ bản

```dart
class _MyAppState extends State<MyApp> with WidgetsBindingObserver {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    // Xử lý khi app paused / resumed / inactive / detached
    if (state == AppLifecycleState.paused) {
      // e.g. pause video, save data
    }
  }

  @override
  void didChangeMetrics() {
    // Xử lý khi kích thước màn hình thay đổi (orientation, keyboard)
  }

  @override
  void didChangeLocales(List<Locale>? locales) {
    // Xử lý khi locale thay đổi
  }

  // … bạn còn có thể override didChangeTextScaleFactor, didChangeAccessibilityFeatures, v.v.
}
```

>**Tóm lại**, `WidgetsBindingObserver` là công cụ mạnh để theo dõi mọi thay đổi “ngoại cảnh” của Flutter engine — khi nào app bị ẩn/hiện, màn hình đổi kích thước, hay người dùng chỉnh setting — và giúp bạn giữ cho UI/logic của mình luôn đồng bộ và mượt mà.

---

## 17. AppLifeCycleState là gì?

- **`AppLifecycleState`** là một **enum** trong Flutter dùng để theo dõi **vòng đời của ứng dụng** (application lifecycle).
- Được sử dụng trong các trường hợp như: tạm dừng app, quay lại app, lưu trạng thái, hoặc xử lý kết nối mạng theo trạng thái app.

### 🧩 Các trạng thái chính:

| Trạng thái        | Mô tả |
|-------------------|-------|
| `resumed`         | Ứng dụng đang **hoạt động** và **hiển thị** trên màn hình. |
| `inactive`        | Ứng dụng **tạm ngừng hoạt động**, không nhận input, có thể đang trong quá trình chuyển đổi trạng thái. |
| `paused`          | Ứng dụng **đã bị ẩn** (chuyển sang background), không tương tác với người dùng. |
| `detached`        | Ứng dụng **bị tách khỏi UI host**, thường thấy trên nền tảng như Flutter web hoặc trong một số trường hợp kỹ thuật đặc biệt. |

### 💡 Cách sử dụng:

```dart
class MyAppState extends State<MyApp> with WidgetsBindingObserver {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused) {
      print('App đang ở background');
    }
  }

  ...
}
```

> Bạn có thể dùng nó để **lưu trạng thái**, **ngắt kết nối socket**, hoặc **tạm dừng video stream** khi app vào background.

---

## 18. MethodChannel là gì?

- **`MethodChannel`** là một lớp trong Flutter dùng để **giao tiếp hai chiều giữa Dart và mã native** (Java/Kotlin cho Android, Swift/Objective-C cho iOS).
- Cho phép bạn **gọi các phương thức gốc từ Dart** hoặc **nhận dữ liệu trả về từ native**, khi Flutter chưa hỗ trợ trực tiếp tính năng đó (ví dụ: lấy pin, cảm biến, camera nâng cao, truyền dữ liệu từ Bluetooth...).

#### ✅ Khi nào dùng MethodChannel?

- Khi bạn cần sử dụng **API native mà Flutter không hỗ trợ sẵn**.
- Ví dụ: lấy mức pin, mở app khác, quét vân tay bằng hardware, truyền dữ liệu NFC,...

<br/>

#### 🔧 Ví dụ cơ bản (Gọi từ Dart → Android)

```dart
import 'package:flutter/services.dart';
import 'package:flutter/material.dart';

class BatteryLevelWidget extends StatefulWidget {
  @override
  _BatteryLevelWidgetState createState() => _BatteryLevelWidgetState();
}

class _BatteryLevelWidgetState extends State<BatteryLevelWidget> {
  static const platform = MethodChannel('samples.flutter.dev/battery');
  String _batteryLevel = 'Unknown battery level.';

  Future<void> _getBatteryLevel() async {
    try {
      final int result = await platform.invokeMethod('getBatteryLevel');
      setState(() {
        _batteryLevel = 'Battery level at $result%.';
      });
    } on PlatformException catch (e) {
      _batteryLevel = "Failed to get battery level: '${e.message}'.";
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(_batteryLevel),
        ElevatedButton(
          onPressed: _getBatteryLevel,
          child: Text("Get Battery Level"),
        ),
      ],
    );
  }
}
```
<br/>

#### 🧩 Android side (MainActivity.kt)

```kotlin
class MainActivity: FlutterActivity() {
  private val CHANNEL = "samples.flutter.dev/battery"

  override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
    super.configureFlutterEngine(flutterEngine)

    MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler {
      call, result ->
      if (call.method == "getBatteryLevel") {
        val batteryLevel = getBatteryLevel()
        if (batteryLevel != -1) {
          result.success(batteryLevel)
        } else {
          result.error("UNAVAILABLE", "Battery level not available.", null)
        }
      } else {
        result.notImplemented()
      }
    }
  }

  private fun getBatteryLevel(): Int {
    val batteryManager = getSystemService(BATTERY_SERVICE) as BatteryManager
    return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
  }
}
```

<br/>


#### 🍎 iOS side (Swift – `AppDelegate.swift`)

#### Bước 1: Mở file `ios/Runner/AppDelegate.swift` và thêm đoạn sau:

```swift
import UIKit
import Flutter

@UIApplicationMain
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {

    let controller = window?.rootViewController as! FlutterViewController
    let batteryChannel = FlutterMethodChannel(name: "samples.flutter.dev/battery",
                                              binaryMessenger: controller.binaryMessenger)
    
    batteryChannel.setMethodCallHandler({
      (call: FlutterMethodCall, result: @escaping FlutterResult) -> Void in
      if call.method == "getBatteryLevel" {
        self.receiveBatteryLevel(result: result)
      } else {
        result(FlutterMethodNotImplemented)
      }
    })

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  private func receiveBatteryLevel(result: FlutterResult) {
    let device = UIDevice.current
    device.isBatteryMonitoringEnabled = true
    let batteryLevel = device.batteryLevel

    if batteryLevel == -1.0 {
      result(FlutterError(code: "UNAVAILABLE",
                          message: "Battery level not available.",
                          details: nil))
    } else {
      result(Int(batteryLevel * 100))
    }
  }
}
```

<br/>

#### ✅ Tổng kết lại flow hoạt động:

| Vai trò        | Công nghệ           | Mục tiêu                              |
|----------------|---------------------|----------------------------------------|
| UI             | Flutter (Dart)      | Hiển thị nút bấm và mức pin            |
| Giao tiếp      | MethodChannel       | Cầu nối giữa Dart ↔ Native             |
| Native Android | Kotlin/Java         | Lấy mức pin từ `BatteryManager`       |
| Native iOS     | Swift/Objective-C   | Lấy mức pin từ `UIDevice.batteryLevel` |

---

## 19. BuildContext là gì?
🔍 What is **BuildContext** in Flutter?
- `BuildContext` is an object that represents the location of a widget in the widget tree.
- It provides access to the widget's position in the tree, which allows it to:
  + Locate its ancestor widgets.
  + Access things like theme, media queries, InheritedWidgets, etc.


---

## 20. Tại sao không nên sử dụng BuildContext trong initState?
- Trong phương thức `initState()`, widget chưa được xây dựng hoàn toàn, do đó `BuildContext` không thể truy cập các widget cha hoặc các dịch vụ như `Theme`, `MediaQuery`, `Navigator`, v.v.
- Nếu bạn cố gắng sử dụng `BuildContext` trong `initState()`, bạn có thể gặp phải lỗi hoặc hành vi không mong muốn, vì cây widget chưa được xây dựng hoàn toàn.

>_Thay vào đó, bạn nên sử dụng `BuildContext` trong các phương thức như `didChangeDependencies()` hoặc `build()`, nơi mà cây widget đã được xây dựng hoàn toàn và bạn có thể truy cập các widget cha và các dịch vụ khác một cách an toàn._

---

## 21. Các loại key trong Flutter
Awesome — the concept of **`Key` in Flutter** is another classic interview topic! Here's a clear, professional explanation you can use:

---

### 🗝️ **What is a `Key` in Flutter?**

- A **`Key`** is an identifier for widgets, elements, and semantic nodes.
- It helps Flutter **differentiate between widgets** in the **widget tree** when rebuilding the UI.



### 🔄 Why is it important?

Flutter builds the UI by comparing **old** and **new widget trees**. Without a `Key`, Flutter assumes widgets are **interchangeable**. With a `Key`, Flutter knows **which specific widget instance should be preserved**, even if its position in the tree changes.

<br/>

### 📦 Common Use Cases
1. **Preserving widget state during rebuilds**
   ```dart
   ListView(children: [
     MyWidget(key: ValueKey('item1')),
     MyWidget(key: ValueKey('item2')),
   ]);
   ```
2. **When reordering widgets in a list**
   - Without keys, Flutter might reuse the wrong widget.
   - With keys, Flutter keeps the right widget and its state.

3. **Forms and TextFields**
   - Prevents fields from losing user input after hot reload or list updates.

<br/>

### 🔑 Types of Keys

| Key Type         | Description |
|------------------|-------------|
| `Key`            | Base class |
| `ValueKey`       | Compares based on a value (e.g. string, int) |
| `ObjectKey`      | Uses object identity |
| `UniqueKey`      | Always unique, forces rebuild |
| `GlobalKey`      | Accesses widget state across the tree (⚠️ use carefully!) |

<br/>

### ⚠️ When to use `Key`
- Only **when needed**, especially in dynamic lists or stateful widgets.
- Overusing `GlobalKey` can hurt performance and should be avoided unless necessary (like accessing form states or scaffold contexts).

<br/>

### ✅ Example

```dart
class MyItem extends StatelessWidget {
  final String title;
  const MyItem({Key? key, required this.title}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Text(title);
  }
}

// Using keys in a list:
ListView(
  children: items.map((item) => MyItem(key: ValueKey(item.id), title: item.title)).toList(),
);
```

---

## 22. Key vs BuildContext

| **Tiêu chí**              | **Key** | **BuildContext** |
|---------------------------|---------|------------------|
| ✅ **Chức năng chính**     | Dùng để nhận diện **duy nhất** một widget trong cây widget | Đại diện cho **vị trí** của widget trong cây widget |
| 🧠 **Mục đích sử dụng**   | Giúp Flutter **so sánh và giữ lại** đúng widget khi rebuild | Dùng để truy cập các thông tin xung quanh widget như `Theme`, `Navigator`, `InheritedWidget`, v.v. |
| 🔄 **Ảnh hưởng đến rebuild** | Có thể ảnh hưởng lớn, giúp giữ state đúng | Không ảnh hưởng trực tiếp đến việc giữ state |
| 🔎 **Ví dụ dùng**         | `ValueKey(id)`, `GlobalKey<FormState>()` | `Navigator.of(context)`, `Theme.of(context)` |
| 🧰 **Dùng trong trường hợp** | ListView có nhiều item thay đổi vị trí, hoặc cần giữ state khi thay đổi | Truy cập widget cha, gọi Navigator, Scaffold, hoặc truyền dữ liệu xuống dưới |
| 🧩 **Kiểu dữ liệu**        | `Key`, `ValueKey`, `UniqueKey`, `GlobalKey` | `BuildContext` (được truyền vào hàm `build`) |
| 📦 **Liên quan đến widget nào** | Gắn vào `Widget` | Luôn có trong `build(context)` của `Widget` |

<br/>

## 🧪 Ví dụ minh họa

### 1. `Key` giữ lại đúng widget

```dart
ListView(
  children: [
    ListTile(
      key: ValueKey(task.id), // Giúp giữ đúng widget khi danh sách thay đổi
      title: Text(task.title),
    )
  ],
)
```

<br/>

#### 2. `BuildContext` để lấy `Navigator`

```dart
ElevatedButton(
  onPressed: () {
    Navigator.of(context).push(...); // Dùng context để điều hướng
  },
)
```


## 🧠 Tổng kết

| Key                         | BuildContext                    |
|----------------------------|----------------------------------|
| "Ai là ai?" – Xác định widget | "Ở đâu trong cây widget?" – Vị trí widget |
| Giúp Flutter **quản lý widget tree** | Giúp bạn **truy cập và điều khiển** môi trường xung quanh widget |

---

## 23. Async và Await trong Dart
- **Async**: Là từ khóa dùng để đánh dấu một hàm là bất đồng bộ (asynchronous). Khi một hàm được đánh dấu là `async`, nó sẽ trả về một `Future` và cho phép bạn sử dụng từ khóa `await` bên trong hàm đó.
- **Await**: Là từ khóa dùng để chờ đợi một `Future` hoàn thành. Khi bạn sử dụng `await`, hàm sẽ tạm dừng cho đến khi `Future` hoàn thành và trả về giá trị. Điều này giúp bạn viết mã bất đồng bộ một cách dễ đọc hơn, giống như mã đồng bộ.
- **Future**: Là một đối tượng đại diện cho một giá trị có thể có trong tương lai. Khi bạn gọi một hàm trả về `Future`, bạn có thể sử dụng `await` để chờ đợi giá trị đó.
- **Stream**: Là một đối tượng đại diện cho một chuỗi các giá trị có thể đến trong tương lai. Bạn có thể lắng nghe (listen) một `Stream` để nhận các giá trị khi chúng đến. `Stream` thường được sử dụng để xử lý dữ liệu liên tục, như sự kiện từ người dùng hoặc dữ liệu từ mạng.
- **StreamController**: Là một đối tượng cho phép bạn tạo và quản lý một `Stream`. Bạn có thể thêm dữ liệu vào `Stream` thông qua `StreamController`, và người nghe (listener) sẽ nhận được các giá trị đó. `StreamController` thường được sử dụng để phát (broadcast) dữ liệu đến nhiều người nghe cùng lúc.
- **StreamBuilder**: Là một widget trong Flutter cho phép bạn xây dựng giao diện dựa trên dữ liệu từ một `Stream`. Khi `Stream` phát ra giá trị mới, `StreamBuilder` sẽ tự động cập nhật giao diện với dữ liệu mới. `StreamBuilder` thường được sử dụng để hiển thị dữ liệu từ mạng hoặc các sự kiện liên tục.
- **FutureBuilder**: Là một widget trong Flutter cho phép bạn xây dựng giao diện dựa trên dữ liệu từ một `Future`. Khi `Future` hoàn thành, `FutureBuilder` sẽ tự động cập nhật giao diện với dữ liệu mới. `FutureBuilder` thường được sử dụng để hiển thị dữ liệu từ mạng hoặc các tác vụ bất đồng bộ khác.
- **AsyncSnapshot**: Là một đối tượng đại diện cho trạng thái của một `Future` hoặc `Stream`. Nó chứa thông tin về dữ liệu, lỗi và trạng thái hiện tại của `Future` hoặc `Stream`. Bạn có thể sử dụng `AsyncSnapshot` để kiểm tra xem dữ liệu đã sẵn sàng hay chưa, có lỗi hay không, và lấy giá trị từ `Future` hoặc `Stream`.
- **StreamSubscription**: Là một đối tượng đại diện cho một kết nối đến một `Stream`. Nó cho phép bạn lắng nghe (listen) các giá trị từ `Stream` và hủy đăng ký (cancel) khi không cần thiết nữa. Bạn có thể sử dụng `StreamSubscription` để kiểm soát việc lắng nghe dữ liệu từ `Stream`, bao gồm việc tạm dừng, tiếp tục hoặc hủy bỏ lắng nghe.
- **Completer**: Là một đối tượng cho phép bạn tạo và hoàn thành một `Future` thủ công. Bạn có thể sử dụng `Completer` để tạo một `Future` và sau đó hoàn thành nó bằng cách gọi `complete()` hoặc `completeError()`. `Completer` thường được sử dụng khi bạn cần tạo một `Future` từ một callback hoặc một sự kiện không đồng bộ khác.
- **Isolate**: Là một đơn vị thực thi độc lập trong Dart, cho phép bạn chạy mã bất đồng bộ mà không làm ảnh hưởng đến luồng chính (main thread). Isolate có bộ nhớ riêng và không chia sẻ trạng thái với luồng chính. Bạn có thể sử dụng Isolate để xử lý các tác vụ nặng mà không làm chậm giao diện người dùng.
- **Isolate.spawn**: Là một phương thức dùng để tạo một Isolate mới. Bạn có thể truyền một hàm và các tham số cần thiết cho Isolate mới. Khi Isolate được tạo, nó sẽ chạy độc lập và không ảnh hưởng đến luồng chính.
- **ReceivePort**: Là một đối tượng cho phép bạn nhận dữ liệu từ một Isolate khác. Bạn có thể tạo một `ReceivePort` và truyền nó cho Isolate mới để nhận dữ liệu từ Isolate đó. `ReceivePort` thường được sử dụng để giao tiếp giữa các Isolate trong Dart.
- **SendPort**: Là một đối tượng đại diện cho một cổng gửi dữ liệu đến một `ReceivePort`. Bạn có thể sử dụng `SendPort` để gửi dữ liệu từ một Isolate đến một ReceivePort. `SendPort` thường được sử dụng để giao tiếp giữa các Isolate trong Dart.

---

## 24. Tại sao không nên sử dụng `async` trong `initState()`?
- Trong `initState()`, widget chưa được xây dựng hoàn toàn, do đó không thể sử dụng `async` để gọi các hàm bất đồng bộ.

---

## 25. Tại sao không nên sử dụng `async` trong `build()`?
- Trong `build()`, widget được xây dựng lại mỗi khi có thay đổi trong cây widget, do đó không nên sử dụng `async` để gọi các hàm bất đồng bộ. Nếu bạn sử dụng `async` trong `build()`, nó

---

## 26. Future có bao nhiêu trạng thái?
- **Future** có 3 trạng thái chính:
  - **Pending**: Trạng thái ban đầu, khi `Future` chưa hoàn thành.
  - **Fulfilled**: Trạng thái khi `Future` hoàn thành thành công và trả về giá trị.
  - **Rejected**: Trạng thái khi `Future` hoàn thành không thành công và trả về lỗi.
- Ngoài ra, `Future` cũng có thể ở trạng thái **canceled** nếu bạn hủy nó trước khi hoàn thành. Tuy nhiên, trạng thái này không phải là một phần chính thức của `Future` trong Dart.

- Khi bạn sử dụng `async` và `await`, bạn có thể dễ dàng xử lý các trạng thái này bằng cách sử dụng `try-catch` để bắt lỗi và xử lý kết quả trả về từ `Future`.
- `Future` cũng có thể được sử dụng với các phương thức như `then()`, `catchError()` và `whenComplete()` để xử lý các trạng thái khác nhau của nó.

---

## 27. Async / Async* / Sync / Sync* trong Dart
- **Async**: Là từ khóa dùng để đánh dấu một hàm là bất đồng bộ (asynchronous). Khi một hàm được đánh dấu là `async`, nó sẽ trả về một `Future` và cho phép bạn sử dụng từ khóa `await` bên trong hàm đó.
- **Async***: Là từ khóa dùng để đánh dấu một hàm là bất đồng bộ và trả về một `Stream`. Khi một hàm được đánh dấu là `async*`, nó sẽ trả về một `Stream` và cho phép bạn sử dụng từ khóa `yield` bên trong hàm đó để phát ra các giá trị liên tục.
- **Sync**: Là từ khóa dùng để đánh dấu một hàm là đồng bộ (synchronous). Khi một hàm được đánh dấu là `sync`, nó sẽ trả về một giá trị ngay lập tức và không thể sử dụng từ khóa `await` bên trong hàm đó.
- **Sync***: Là từ khóa dùng để đánh dấu một hàm là đồng bộ và trả về một `Iterable`. Khi một hàm được đánh dấu là `sync*`, nó sẽ trả về một `Iterable` và cho phép bạn sử dụng từ khóa `yield` bên trong hàm đó để phát ra các giá trị liên tục.

>Ví dụ dưới đây sẽ giúp bạn hiểu rõ hơn về các loại hàm này:

#### 1. Đồng bộ, giá trị đơn (`sync`)
Một hàm bình thường, chạy ngay lập tức và trả về một giá trị.

```dart
String greetSync(String name) {
  return 'Xin chào, $name!';
}

void main() {
  print(greetSync('Hoàng')); // in ngay lập tức
}
```


#### 2. Không đồng bộ, giá trị đơn (`async`)
Được đánh dấu là `async`, nó trả về một `Future<T>`, có thể sử dụng `await` bên trong và chỉ trả về một kết quả (hoặc lỗi).

```dart
Future<String> fetchData() async {
  await Future.delayed(Duration(seconds: 2));
  return 'Dữ liệu đã được tải xong!';
}

void main() async {
  print('Đang yêu cầu...');
  final data = await fetchData(); 
  print(data); // in sau ~2s
}
```


#### 3. Bộ tạo đồng bộ (`sync*`)
Được đánh dấu là `sync*`, trả về một `Iterable<T>`. Bạn sử dụng `yield` để trả về giá trị từng cái một và chúng sẽ được tạo ra một cách lười biếng khi người gọi lặp qua chúng.

```dart
Iterable<int> evenNumbersSync(int to) sync* {
  for (var i = 0; i <= to; i += 2) {
    yield i;
  }
}

void main() {
  for (var n in evenNumbersSync(6)) {
    print(n); // 0, 2, 4, 6
  }
}
```

#### 4. Bộ tạo không đồng bộ (`async*`)
Được đánh dấu là `async*`, trả về một `Stream<T>`. Bạn sử dụng `yield` để trả về giá trị theo thời gian (có thể `await` giữa các lần `yield`), rất hữu ích cho các chuỗi sự kiện không đồng bộ.

```dart
Stream<int> evenNumbersAsync(int to) async* {
  for (var i = 0; i <= to; i += 2) {
    await Future.delayed(Duration(seconds: 1));
    yield i;
  }
}

void main() async {
  await for (var n in evenNumbersAsync(6)) {
    print(n); // in 0, sau 1s in 2, sau đó 4 và 6
  }
}
```

---

| Loại hàm       | Từ khóa | Kiểu trả về     | Dùng cho…                           |
|----------------|---------|-----------------|-------------------------------------|
| sync           | không   | `T`             | Giá trị ngay lập tức, một lần duy nhất |
| async          | `async` | `Future<T>`     | Một giá trị sau công việc không đồng bộ |
| sync*          | `sync*` | `Iterable<T>`   | Dãy giá trị được tạo ra lười biếng  |
| async*         | `async*`| `Stream<T>`     | Chuỗi giá trị sự kiện không đồng bộ  |

Chọn loại hàm phù hợp với nhu cầu của bạn:  
- Giá trị đơn giản, ngay lập tức → **sync**  
- Giá trị một lần có thể chờ → **async**  
- Dãy giá trị theo yêu cầu → **sync***  
- Dãy giá trị theo thời gian hoặc sự kiện không đồng bộ → **async***

---

## 28. yield và yield* trong Dart
- **`yield`**: Dùng trong các hàm `sync*` hoặc `async*` để phát ra một giá trị đơn lẻ. Khi bạn gọi hàm này, nó sẽ trả về giá trị ngay lập tức và tạm dừng thực thi cho đến khi có yêu cầu tiếp theo.
- **`yield*`**: Dùng trong các hàm `sync*` hoặc `async*` để phát ra tất cả các giá trị từ một iterable hoặc stream khác. Khi bạn gọi hàm này, nó sẽ phát ra tất cả các giá trị từ iterable hoặc stream đó mà không cần phải lặp qua từng giá trị một cách thủ công.

```dart
// Ví dụ về yield
Iterable<int> countUpTo(int n) sync* {
  for (int i = 1; i <= n; i++) {
    yield i; // phát ra từng giá trị
  }
}

// Ví dụ về yield*
Iterable<int> countUpToWithYieldStar(int n) sync* {
  yield* countUpTo(n); // phát ra tất cả giá trị từ hàm khác
}
















